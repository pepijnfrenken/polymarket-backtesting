"""Core type definitions for the Polymarket backtesting library."""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from enum import StrEnum
from typing import Any, Callable


class OrderType(StrEnum):
    """Type of order to execute."""

    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class OrderSide(StrEnum):
    """Side of the order (buy or sell)."""

    BUY = "buy"
    SELL = "sell"


class Outcome(StrEnum):
    """Outcome for a binary prediction market."""

    YES = "yes"
    NO = "no"


@dataclass
class Signal:
    """Trading signal generated by a strategy.

    Attributes:
        market_id: Unique identifier for the market
        outcome: Which outcome to trade (yes or no)
        action: Buy or sell
        size: Dollar amount to trade
        order_type: Type of order (market, limit, etc.)
        limit_price: Limit price for limit orders
        stop_price: Stop price for stop orders
    """

    market_id: str
    outcome: Outcome
    action: OrderSide
    size: float
    order_type: OrderType = OrderType.MARKET
    limit_price: float | None = None
    stop_price: float | None = None


@dataclass
class Order:
    """An order ready for execution.

    Attributes:
        signal: The original signal that generated this order
        status: Current status of the order
        created_at: When the order was created
        filled_at: When the order was filled (if applicable)
    """

    signal: Signal
    status: str = "pending"
    created_at: datetime = field(default_factory=datetime.now)
    filled_at: datetime | None = None


@dataclass
class Position:
    """A position in a market outcome.

    Attributes:
        market_id: Unique identifier for the market
        outcome: Which outcome (yes or no)
        quantity: Number of tokens held
        entry_price: Price at which position was entered
        entry_time: When the position was entered
        unrealized_pnl: Current unrealized profit/loss
        realized_pnl: Realized profit/loss from closed trades
    """

    market_id: str
    outcome: Outcome
    quantity: float
    entry_price: float
    entry_time: datetime = field(default_factory=datetime.now)
    unrealized_pnl: float = 0.0
    realized_pnl: float = 0.0

    @property
    def cost_basis(self) -> float:
        """Total cost of the position."""
        return self.quantity * self.entry_price

    @property
    def current_value(self, current_price: float) -> float:
        """Current value of the position given a price."""
        return self.quantity * current_price

    def update_unrealized_pnl(self, current_price: float) -> None:
        """Update unrealized P&L based on current price."""
        self.unrealized_pnl = self.current_value(current_price) - self.cost_basis


@dataclass
class Fill:
    """Record of an order execution.

    Attributes:
        order: The order that was filled
        market_id: Market identifier
        outcome: Outcome traded
        side: Buy or sell
        quantity: Number of tokens filled
        price: Fill price
        commission: Commission/fee paid
        timestamp: When the fill occurred
    """

    order: Order
    market_id: str
    outcome: Outcome
    side: OrderSide
    quantity: float
    price: float
    commission: float = 0.0
    timestamp: datetime = field(default_factory=datetime.now)

    @property
    def total_cost(self) -> float:
        """Total cost including commission."""
        return self.quantity * self.price + self.commission


@dataclass
class Trade:
    """Completed trade record for history.

    Attributes:
        market_id: Market identifier
        outcome: Outcome traded
        side: Buy or sell
        quantity: Number of tokens
        price: Trade price
        pnl: Profit/loss from this trade
        entry_time: When position was opened
        exit_time: When position was closed
        commission: Total commission paid
    """

    market_id: str
    outcome: Outcome
    side: OrderSide
    quantity: float
    price: float
    pnl: float = 0.0
    entry_time: datetime = field(default_factory=datetime.now)
    exit_time: datetime = field(default_factory=datetime.now)
    commission: float = 0.0


# Type alias for fee calculation functions
FeeCalculator = Callable[[float, float, bool], float]
"""Fee calculator function signature: (price, quantity, is_maker) -> fee"""
